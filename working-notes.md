---
marp: true
---

# Part 3
* More on classes

---

# Default values
```
class Temperature(val value: Double, val unit: String = "Celsius") {
    override fun toString() = "Temperature is $value $unit"
}

println(Temperature(17.5, "Fahrenheit"))
println(Temperature(21.5))

Temperature is 17.5 Fahrenheit
Temperature is 21.5 Celsius
```
<!--
Støttes ikke fra Java. 
-->

---
# Multiple constructors
```kotlin
class Temperature(val value: Double, val unit: String) {
    constructor(value: Double) : this(value, "Celsius")

    override fun toString() = "Temperature is $value $unit"
}

println(Temperature(17.5, "Fahrenheit"))
println(Temperature(21.5))

Temperature is 17.5 Fahrenheit
Temperature is 21.5 Celsius
```
<!--
Rotete med mange konstruktører
-->

---
# Companion (creational pattern)
```kotlin
class Temperature(val value: Double, val unit: String = "Celsius") {
    override fun toString() = "Temperature is $value $unit"

    companion object{
        fun of(value: Double) = Temperature(value)
    }
}
```
```java
Temperature.Companion.of(3.5));
```
<!-- .Companion gir singletonen -->

---
@JvmStatic
```kotlin
class Temperature(val value: Double, val unit: String = "Celsius") {
    override fun toString() = "Temperature is $value $unit"

    companion object{
        @JvmStatic fun of(value: Double) = Temperature(value)
    }
}
```
```java
Temperature.of(3.5));
```
---
# Scoping functions
* let
* with
* apply
* run
* also

---
# let
* Will run on non-null objects
* Last statement returned
```kotlin
var canBeNull: String? = "Something"

canBeNull?.let{ 
    println("Not null: $it")
}

val upper = canBeNull?.let{ st ->
    st.uppercase()
}

```
---
# Without and with let
```kotlin
val alice = Person("Alice", 20, "Amsterdam")
println(alice)
alice.moveTo("London")
alice.incrementAge()
println(alice)
```
```kotlin
Person("Alice", 20, "Amsterdam").let {
    println(it)
    it.moveTo("London")
    it.incrementAge()
    println(it)
}
```

---
# with
* Multiple operations on same object
* Last statement returned
```kotlin
val numbers = mutableListOf("one", "two", "three")
val w = with(numbers) {
    val firstItem = first()
    val lastItem = last()
    println("First item: $firstItem, last item: $lastItem")
    42
}
println (w)
> 42
```
---
# apply
* Multiple assignments on same object
* The object is resturned
* Object configuration
```kotlin
val adam = Person("Adam").apply {
    age = 32
    city = "London"        
}
println(adam)
```
---
# run
* Extension on "receiver object"
* Can use it's methods without reference
  * as an internal function
```kotlin
val str = "Hello"
    // this
    val lastStatement = str.run {
        println("The receiver string length: $length")
        //println("The receiver string length: ${this.length}") // does the same
    }
```    
---
# also
* Takes the object as niput
* Returns the object
```kotlin
val two = listOf(1, 2, 3, 4, 5)
    .filter { it % 2 == 0 }
    .also { println(it) }
    .first()
println(two)
```
<!--
Bruker det i midten av listeoperasjoner hvor jeg ikke ønsker å avbryte strømmen.
-->
---
# Mixing Java and Kotlin
* Named arguments when instansiating Java classes
---

* Si noe i starten om funksjonell programmering:
   * immutable
   * filter, map, reduce
   * functions FCC

* Add part 3 to outline of workshop
* klasse:
   * constructor args (not val/var)
   * inti {}
   * rekkefølge på dem

# Etter workshop:
fun returnLambda() = { () -> println("Lambda")}
fun returnLambda() { println("Lambda") }

data class osm testdata med copy og default named arguments

@JvmStatic

object og companion object fra java

object:
* - Can inherit classes
* - Can implement interfaces 

generics

immutable lists to java and back

---
Removed slides

## Getters and setters
Full syntax:

```kotlin
var <propertyName>[: <PropertyType>] [= <property_initializer>]
    [<getter>]
    [<setter>]
```
```kotlin
class Person(firstName: String){
    var name = firstName
        get() = field.toUpperCase()
        set(value){
            field = value
        }
}

val bjorn = Person("Bjørn")
println(bjorn.name)
```

<!--
Note:
- a backing fields is generated if needed
- getter and setter are generated by default unless specified
-->

---

## Generated getter/setter
```kotlin
class Person(firstName: String){
    val name = firstName.toUpperCase()
}
val bjorn = Person("Bjørn")
println(bjorn.name)
```
or even simpler:
```kotlin
class Person(val firstName: String)
val bjorn = Person("Bjørn")
println(bjorn.name)
```

<!-- 
Note: 
- val could be var
-->

---

## Access modifiers
- Properties and methods of a class can be:
   - public (default): available to all
   - private: only available from within the class
   - protected: available within the class, in sub-classes and classes in same package
   - internal: available from any code in the same module (=compiled together)

---
## Using collections
 - Like in Java
 - No .stream() or .collect()
 - Use { and }

---

## More about classes
 - Can be abstract, sealed, open
 - Can have several constructors
 - Can implement interfaces
 - supports inheritance
 - ...whatever java classes can do
--